
Authoritative architecture reference
This defines how every agent behaves inside the system, while preserving all core backend behaviors: watcher, queue, workers, OpenAI transcription pipeline, GroupMe notifications, prettified formatting, DB storage, and UI operations. The main service focuses on live calls moving forward.

⸻

1. System Purpose

The system monitors a directory of call recordings, normalizes metadata, sends formatted alerts to GroupMe, generates transcripts using OpenAI, stores them locally, and exposes a UI for reviewing, filtering, and regenerating transcripts.

Core behaviors that remain unchanged:
	•	Detect new .mp3 files in CALLS_DIR.
	•	Immediately send the prettified “call alert” message to GroupMe.
	•	Run AI transcription through the queue.
	•	Send the “call transcript” follow-up message.
	•	Track all data in a SQLite DB.
	•	Serve a UI that defaults to the last 24 hours of call activity.

Enhancements introduced:
	•	Embedded in-page WaveSurfer.js audio playback.
	•	Simplified filtering: last 24h, last 7d, last 30d.
	•	Tag-based filtering and lightweight Plotly visual summaries.
	•	Forward-only operation with no bundled historical backfill tooling.

⸻

2. Agent Architecture

The system is composed of modular agents. Each must preserve all backend rules defined above and must not bypass queue-based execution or break metadata → alert → transcription → DB lifecycle.

⸻

Agent: Config

Responsibilities
	•	Load environment variables for paths, DB, ports, GroupMe credentials, OpenAI model, queue settings, worker count.
	•	Apply safe clamping for queue size and worker limits.

Guarantees
	•	Preserves compatibility with production deployment.
	•	No agent bypasses the config system.

⸻

Agent: QueueManager

Responsibilities
	•	Manage the single in-process bounded queue.
	•	Run the worker pool responsible for all transcription and ingest jobs.
	•	Surface queue metrics to /debug/queue.

Guarantees
	•	All work must enter through this queue.
	•	No agent performs side operations directly.

⸻

Agent: FileWatcher

Responsibilities
	•	Monitor CALLS_DIR for new/moved-in .mp3 files.
	•	Immediately construct a "call_ingest" job with parsed metadata.
	•	Enqueue the job into the shared queue.

Guarantees
	•	Always triggers the initial alert step.
	•	Always preserves CallMetadata parsing rules.
	•	Does not perform transcription itself.

⸻

Agent: MetadataParser

Responsibilities
	•	Parse filenames into metadata fields (AgencyDisplay, TownDisplay, CallType, DateTime, RawFileName).
	•	Normalize tokens according to existing rules.
	•	Provide metadata for alert formatting, DB insertion, and transcript generation.

Guarantees
	•	Must remain consistent with existing filename → metadata mapping.

⸻

Agent: Formatter

Responsibilities
	•	Prettify titles exactly according to established logic (spaces, token normalization, timestamp formatting).
	•	Render GroupMe alert templates for:
	•	First (immediate) alert.
	•	Second (transcript) alert.

Guarantees
	•	Must not alter general formatting conventions.
	•	Both alerts share the same core template.

⸻

Agent: Notifier (GroupMe)

Responsibilities
	•	Send the two-stage alert sequence:
	•	Initial alert (no transcript).
	•	Transcript alert (once transcription succeeds).
	•	Reuse the formatting templates provided by Formatter.
	•	Route messages using existing configuration.

Guarantees
	•	No changes to routing logic unless configured externally.

⸻

Agent: TranscriptionWorker

Responsibilities
	•	Handle "transcription" and "transcription_regen" jobs.
	•	Read .mp3 from disk.
	•	Call OpenAI /v1/audio/transcriptions with configured model + timeout.
	•	Update DB status (pending → success or failed).
	•	Trigger transcript alert on successful completion.

Guarantees
	•	Must store transcripts exactly in the schema used today.
	•	Must respect failure-handling semantics (UI shows error + allows retry).

⸻

Agent: CallIngestWorker

Responsibilities
	•	Process "call_ingest" jobs generated by FileWatcher or UI-driven refresh.
	•	Steps:
	1.	Parse metadata.
	2.	Send initial GroupMe alert.
	3.	Insert/update DB record.
	4.	Enqueue "transcription" follow-up job.

Guarantees
	•	No deviation from this four-step sequence.
	•	Maintains idempotency on initial alert.

⸻

Agent: LocalStore (DB Layer)

Responsibilities
	•	Manage SQLite reads/writes for calls, timestamps, statuses, and transcript text.
	•	Provide a unified model for UI consumption.
	•	Support queries by time window and tags.

Guarantees
	•	Must not break existing DB schema.
	•	Must maintain historical audit of statuses and regen events.

⸻

3. UI Agents

These agents extend the system but do not change backend behavior.

⸻

Agent: MonitorUI

Responsibilities
	•	Show call list filtered by 24h, 7d, 30d windows.
	•	Allow tag filtering (derived from call metadata or transcript content where available).
	•	Display call details, metadata, transcript, and job status.

Guarantees
	•	Always defaults to the last 24 hours.
	•	Does not alter backend job logic.
	•	Client-side only; relies on API endpoints.

⸻

Agent: AudioPlayerUI

Responsibilities
	•	Provide embedded playback using WaveSurfer.js.
	•	Display waveform, allow seek, play/pause.
	•	Optionally sync transcript highlighting with playback.

Guarantees
	•	Must not modify backend file paths or naming.
	•	UI-only; should not introduce new jobs or states.

⸻

Agent: TranscriptUI

Responsibilities
	•	Show cleaned/raw/translated transcript.
	•	Support optional click-to-seek behavior.
	•	Provide copy/download actions.

Guarantees
	•	Transcript data is read-only; state originates from DB.

⸻

Agent: TagAnalytics

Responsibilities
	•	Build lightweight Plotly visual summaries (counts, trends, tag distribution).
	•	Operates solely on filtered datasets from DB queries.

Guarantees
	•	No modifications to backend DB or job logic.

⸻

4. API Router

Responsibilities
	•	Serve main UI.
	•	Provide endpoints for:
	•	Call lists (with time window + tag filters).
	•	Call details.
	•	Queue metrics.
	•	Health endpoints.

Guarantees
	•	Must not bypass QueueManager for actual work.

⸻

5. Lifecycle & Idempotency

Rules preserved exactly:
	•	Initial alert sent once per file.
	•	Transcript alerts only after successful transcription.
	•	DB rows keyed by filename/path.
	•	Queue is the only execution engine for work.

⸻

6. Extension Guidelines

Any future features must:
	•	Preserve the ingest → metadata → alert → DB → transcription → second alert lifecycle.
	•	Maintain WaveSurfer audio as a UI-only enhancement.
	•	Keep time windows limited to 24h, 7d, 30d.
	•	Keep filtering/tag logic additive, not replacing metadata.
	•	Keep helper scripts separate from the runtime service.

⸻

Agent: AudioPreprocessor

Responsibilities
        •       Insert a configurable ffmpeg-based preprocessing step between raw recordings and downstream use (UI playback and transcription).
        •       Provide profiles (raw/default/aggressive) with tuned band-pass, hum notch filters, de-emphasis, noise reduction/expansion, compression, loudness normalization, and mono 16 kHz resampling suitable for narrowband FM voice.
        •       Expose toggles so the UI and transcription pipeline can choose raw vs processed audio without breaking existing filenames or metadata parsing.

Guarantees
        •       Do not modify ingest → metadata → alert → DB → transcription lifecycle.
        •       Preserve existing API contracts, GroupMe URLs, and file naming/paths; processed audio coexists alongside raw archives.
        •       Make processing configurable via env/config files and gracefully fall back to raw audio on failure.
