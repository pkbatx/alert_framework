from __future__ import annotations

from dataclasses import dataclass
from pathlib import Path
from typing import Dict, Iterable, List

DOC_BEGIN = "<!-- CAAD_DOCS_BEGIN -->"
DOC_END = "<!-- CAAD_DOCS_END -->"


@dataclass(frozen=True)
class DocChange:
    path: Path
    changed: bool
    created: bool


def _find_repo_root() -> Path:
    start = Path.cwd().resolve()
    for parent in [start] + list(start.parents):
        if (parent / "contracts").is_dir():
            return parent
        if (parent / ".git").exists():
            return parent
    return start


def _managed_block(content: str) -> str:
    return f"{DOC_BEGIN}\n{content.strip()}\n{DOC_END}\n"


def _apply_managed_section(existing: str, content: str) -> str:
    block = _managed_block(content)
    if DOC_BEGIN in existing and DOC_END in existing:
        pre, _ = existing.split(DOC_BEGIN, 1)
        _, post = existing.split(DOC_END, 1)
        return f"{pre}{block}{post.lstrip()}"
    existing = existing.rstrip()
    if not existing:
        return block
    return f"{existing}\n\n{block}"


def _write_if_changed(path: Path, content: str, write: bool) -> DocChange:
    existed = path.exists()
    existing = path.read_text() if existed else ""
    updated = _apply_managed_section(existing, content)
    changed = updated != existing
    if write and changed:
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(updated)
    return DocChange(path=path, changed=changed, created=not existed)


def _boundary_targets(root: Path) -> Dict[str, Path]:
    candidates = {
        "skills": root / "skills",
        "contracts": root / "contracts",
        "runtime": root / "runtime",
        "models": root / "models",
        "worker": root / "worker",
        "backend": root / "backend",
        "scripts": root / "scripts",
        "docker": root / "docker",
    }
    return {name: path for name, path in candidates.items() if path.is_dir()}


def build_structure_section() -> str:
    root = _find_repo_root()
    lines: List[str] = [
        "## Repository Structure (managed)",
        "",
        "High-level boundaries generated by `caad docs` to reduce drift.",
        "",
    ]
    boundaries = _boundary_targets(root)
    descriptions = {
        "skills": "repo-local skillkit and CLI (`caad`) for AI, env, ops, and docs",
        "contracts": "JSON schemas that define call artifacts and AI outputs",
        "runtime": "generated artifacts and call records (gitignored)",
        "models": "LocalAI model configs and binaries (binaries gitignored)",
        "worker": "file-based ingestion worker (polling watcher + pipeline)",
        "backend": "legacy Go backend and refinement helpers (not used in Phases 0–2)",
        "scripts": "local helper scripts (dev reset, smoke)",
        "docker": "Docker helper assets referenced by the Dockerfile",
    }
    for name in sorted(boundaries.keys()):
        desc = descriptions.get(name, "boundary directory")
        lines.append(f"- `{name}/` — {desc}")
    lines.append("")
    lines.append("For details, see the boundary README files generated per directory.")
    return "\n".join(lines)


def build_readme_section() -> str:
    return "\n".join(
        [
            "## CAAD System Overview (managed)",
            "",
            "This repository is evolving in phased increments. Phases 0–2 establish:",
            "",
            "- JSON contracts in `contracts/`",
            "- A file-based artifact store under `runtime/`",
            "- A polling ingestion worker in `worker/`",
            "- A repo-local skillkit CLI in `skills/`",
            "",
            "See `STRUCTURE.md` for the authoritative top-level map.",
        ]
    )


def build_boundaries() -> Dict[str, str]:
    root = _find_repo_root()
    boundaries = _boundary_targets(root)
    descriptions = {
        "skills": "Repo-local skillkit and CLI used for AI, env, ops, and docs.",
        "contracts": "Authoritative JSON schemas for artifacts and AI outputs.",
        "runtime": "Generated artifacts and call records; ignored by git.",
        "models": "LocalAI model configs and binaries (binaries ignored).",
        "worker": "File-based ingestion worker for call artifacts.",
        "backend": "Legacy Go backend modules; not used in Phases 0–2.",
        "scripts": "Local helper scripts (dev reset, smoke).",
        "docker": "Docker helper assets referenced by the Dockerfile.",
    }
    results: Dict[str, str] = {}
    for name in sorted(boundaries.keys()):
        results[name] = "\n".join(
            [
                f"## `{name}/` boundary (managed)",
                "",
                descriptions.get(name, "Boundary directory."),
                "",
                "Managed content is appended below; do not edit between markers.",
            ]
        )
    return results


def docs_structure(write: bool) -> List[DocChange]:
    root = _find_repo_root()
    target = root / "STRUCTURE.md"
    return [_write_if_changed(target, build_structure_section(), write)]


def docs_readme(write: bool) -> List[DocChange]:
    root = _find_repo_root()
    target = root / "README.md"
    return [_write_if_changed(target, build_readme_section(), write)]


def docs_boundaries(write: bool) -> List[DocChange]:
    root = _find_repo_root()
    changes: List[DocChange] = []
    for name, content in build_boundaries().items():
        target = root / name / "README.md"
        changes.append(_write_if_changed(target, content, write))
    return changes


def _summarize(changes: Iterable[DocChange]) -> Dict[str, List[str]]:
    changed = [str(change.path) for change in changes if change.changed]
    created = [str(change.path) for change in changes if change.created]
    return {"changed": sorted(changed), "created": sorted(created)}


def docs_all(write: bool) -> Dict[str, List[str]]:
    changes: List[DocChange] = []
    changes.extend(docs_structure(write))
    changes.extend(docs_readme(write))
    changes.extend(docs_boundaries(write))
    return _summarize(changes)


def docs_validate() -> Dict[str, List[str]]:
    summary = docs_all(write=False)
    if summary["changed"]:
        raise RuntimeError("documentation is out of date")
    return summary
